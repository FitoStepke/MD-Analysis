import MDAnalysis as mda
import numpy as np

def analyze_calcium_changes_with_out_limit(output_file, max_out_frames=100, min_out_to_ignore=100, min_valid_frames=100):
    """
    Analyze calcium site changes while only counting changes between valid sites
    if there are fewer than `max_out_frames` consecutive "OUT" frames.
    Additionally, ignore frames where all calciums are "OUT" for less than `min_out_to_ignore`
    consecutive frames in the distribution calculation.

    Parameters:
        output_file (str): Path to the output file generated by trajectory analysis.
        max_out_frames (int): Maximum number of consecutive "OUT" frames allowed
                              between two valid sites to count a change.
        min_out_to_ignore (int): Minimum number of consecutive "OUT" frames required
                                 to exclude them from valid calcium distribution.
        min_valid_frames (int): Minimum number of frames required in a valid site to count a change.
    """
    # Read the output file
    with open(output_file, "r") as f:
        lines = f.readlines()

    # Extract headers (e.g., CAL1, CAL2, etc.)
    headers = lines[0].strip().split("\t")[1:]

    # Initialize counters and trackers for calcium changes
    change_counts = {header: 0 for header in headers}
    time_in_positions = {header: 0 for header in headers}  # Tracks frames in non-OUT positions
    current_site = {header: None for header in headers}
    out_frame_count = {header: 0 for header in headers}  # Tracks consecutive "OUT" frames
    frame_count = {header: 0 for header in headers}  # Tracks frame streaks for valid sites

    # Distribution tracking variables
    valid_calcium_distribution = {i: 0 for i in range(2, 7)}  # 2 to 6 calcios in valid positions
    total_frames = 0
    consecutive_out_frames = 0  # Tracks consecutive frames where all calciums are "OUT"

    # Iterate over each line (frame) in the file, skipping the header
    for line in lines[1:]:
        values = line.strip().split("\t")
        current_sites = dict(zip(headers, values[1:]))  # Ignore the frame column

        # Count the number of calciums in valid positions for this frame
        valid_count = sum(1 for cal in headers if current_sites[cal] != "OUT")

        # Check if all calciums are in "OUT"
        if valid_count == 0:
            consecutive_out_frames += 1
        else:
            # Only consider the valid frame if the previous "OUT" segment is long enough
            if consecutive_out_frames < min_out_to_ignore:
                total_frames -= consecutive_out_frames  # Remove short OUT segments from total count
            consecutive_out_frames = 0
            total_frames += 1

            # Update valid calcium distribution if there are valid calciums
            if valid_count >= 2:
                valid_calcium_distribution[valid_count] += 1

        # Check each calcium ion for changes
        for cal in headers:
            new_site = current_sites[cal]

            if new_site == "OUT":
                # Increment OUT frame count
                out_frame_count[cal] += 1
                continue

            # Increment time spent in valid positions
            time_in_positions[cal] += 1

            if new_site == current_site[cal]:
                # Increment frame count if the site hasn't changed
                frame_count[cal] += 1
            else:
                # If the previous site was valid, count the change if OUT frames are below the threshold
                if current_site[cal] is not None and frame_count[cal] >= min_valid_frames and out_frame_count[cal] <= max_out_frames:
                    change_counts[cal] += 1

                # Update to the new site and reset counters
                current_site[cal] = new_site
                frame_count[cal] = 1
                out_frame_count[cal] = 0

    # Calculate the proportions for valid calcium counts
    proportions = {key: valid_calcium_distribution[key] / total_frames for key in valid_calcium_distribution}

    # Calculate change rates (changes per valid frame) for each calcium
    change_rates = {
        cal: (change_counts[cal] / time_in_positions[cal] if time_in_positions[cal] > 0 else 0)
        for cal in headers
    }

    # Calculate the total weighted ratio
    weighted_ratio = sum(
        (sum(change_rates.values()) * proportions[key]) / key
        for key, count in valid_calcium_distribution.items()
        if count > 0
    ) * 100000  # Convert to events/µs

    # Prepare results for saving
    analysis_lines = []
    analysis_lines.append("Calcium Site Change Counts and Rates (100 frames minimum per site, OUT limit applied):")
    for cal in headers:
        rate = change_rates[cal] * 100000  # Convert to events/µs
        analysis_lines.append(f"{cal}: {change_counts[cal]} changes, {time_in_positions[cal]} frames in positions, "
                              f"rate = {rate:.2f} events/µs")

    # Add distribution of valid calcium counts
    analysis_lines.append("\nDistribution of valid calcium counts per frame (ignoring short OUT segments):")
    for key, count in valid_calcium_distribution.items():
        analysis_lines.append(f"{key} calcios: {count} frames ({proportions[key] * 100:.2f}%)")

    # Add the weighted ratio
    analysis_lines.append(f"\nWeighted ratio (events/µs): {weighted_ratio:.2f}")

    # Save results to a new file
    output_analysis_file = os.path.splitext(output_file)[0] + "_changes_with_100frame_limit.txt"
    with open(output_analysis_file, "w") as f_out:
        f_out.write("\n".join(analysis_lines))

    print(f"Analysis complete with 100 frame limits applied. Results saved to {output_analysis_file}")

# Example usage
if __name__ == "__main__":
    # Path to the output file
    output_file = "calcium_sites_3R2.txt"

    # Run the analysis with an OUT frame limit of 100 and ignore short OUT segments
    analyze_calcium_changes_with_out_limit(output_file, max_out_frames=500, min_out_to_ignore=500, min_valid_frames=100)






















    
   

